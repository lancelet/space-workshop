\documentclass[12pt,openany]{book}

%------------------------------------------------------------------------------
% PRELUDE
%------------------------------------------------------------------------------

% Don't pause on errors (useful for CI)
\nonstopmode

% Font encoding
\usepackage[T1]{fontenc}

% Set fonts
\usepackage{fontspec}
\setmainfont{Tex Gyre Pagella}
\setsansfont{Tex Gyre Adventor}

% Set up page geometry (margins, etc)
\usepackage[a4paper,top=2.5cm,bottom=2.5cm,left=2cm,right=2cm]{geometry}

% Allow inclusion of external graphics with graphicx
\usepackage{graphicx}

% AMS mathematics
\usepackage{amsmath}

% Bibliography style
\usepackage[numbers]{natbib}

% Hyperlinks
\usepackage[breaklinks,hidelinks]{hyperref}

% More sophisticated tables
\usepackage{booktabs}

% Formatting chemical isotopes
\usepackage{isotope}

% Caption customization
\usepackage[format=hang,labelfont=bf]{caption}

% Color specification
\usepackage{xcolor}

% Color boxes
\usepackage{tcolorbox}
\tcbuselibrary{skins}
\definecolor{midpurple}{RGB}{93,76,134}
\definecolor{vlightgrey}{RGB}{240,240,240}

% Problem boxen
\newtcolorbox[auto counter]{problem}[2][]{%
  colback=vlightgrey,colframe=midpurple,fonttitle=\bfseries,
  title=Problem~\thetcbcounter: #2,#1}

% Fancy headers
\usepackage{fancyhdr}
\pagestyle{plain}

% Set the title of the table of contents and bibliography
\renewcommand{\contentsname}{Table of Contents}
\renewcommand{\bibname}{References}

% Paragraph setting
\setlength{\parindent}{0em}
\setlength{\parskip}{1.1\baselineskip}
\linespread{1.1}

% Enumerate and itemize *within* paragraphs
\usepackage{enumitem}
\newlist{paritemize}{itemize}{1}
\setlist[paritemize]{label=\textbullet,nosep,topsep=-0.75\parskip}
\newlist{probitemize}{itemize}{1}
\setlist[probitemize]{label=\textbullet,nosep}
\newlist{pardescription}{description}{1}
\setlist[pardescription]{nosep,topsep=-0.75\parskip}

% Chapter styling
\usepackage{quotchap}
\makeatletter
\renewcommand*{\chapnumfont}{%
  \usefont{T1}{\@defaultcnfont}{b}{n}\fontsize{80}{100}\selectfont% Default: 100/130
  \color{midpurple}%
}
\makeatother

% Nice(r) fraction symbols
\usepackage{nicefrac}

% Show oferfull boxes and lines
\overfullrule=2pt

% Code snippets
\usepackage{minted}
\newcommand{\filename}[1]{\texttt{#1}}  % inline file name
\newcommand{\code}[1]{\texttt{#1}}      % inline code snippet
\newcommand{\hspackage}[1]{\href{http://hackage.haskell.org/package/#1}{\texttt{#1}}}

% Title and Author
\usepackage{titling}
\title{Haskell Spaceflight Workshop}
\author{Jonathan Merritt \and Luke Clifton}
\date{YOW! LambdaJam 2019, May 13--15}

% Glossary of mathematical symbols
\usepackage{siunitx}
\sisetup{per-mode = symbol}
\usepackage[symbols,nogroupskip]{glossaries-extra}
\glsxtrnewsymbol[description={A function.}]{f}{\ensuremath{f}}
\glsxtrnewsymbol[description={Total force, scalar (\si{N}).}]{Fs}{\ensuremath{F}}
\glsxtrnewsymbol[description={Thrust force, scalar (\si{N}).}]{FTs}{\ensuremath{F_T}}
\glsxtrnewsymbol[description={Standard gravity (\SI{9.80665}{m/s^2}).}]{g0}{\ensuremath{g_0}}
\glsxtrnewsymbol[description={Time step (\si{s}).}]{dt}{\ensuremath{h}}
\glsxtrnewsymbol[description={Vacuum specific impulse (\si{s}).}]{Is}{\ensuremath{I_s}}
\glsxtrnewsymbol[description={Spring constant (\si{N/m}).}]{k}{\ensuremath{k}}
\glsxtrnewsymbol[description={Mass (\si{kg}).}]{m}{\ensuremath{m}}
\glsxtrnewsymbol[description={Dry mass; mass of rocket stage without propellant (\si{kg}).}]{md}{\ensuremath{m_d}}
\glsxtrnewsymbol[description={Final mass (\si{kg}).}]{mf}{\ensuremath{m_f}}
\glsxtrnewsymbol[description={Initial mass (\si{kg}).}]{mi}{\ensuremath{m_i}}
\glsxtrnewsymbol[description={Propellant mass (\si{kg}).}]{mp}{\ensuremath{m_p}}
\glsxtrnewsymbol[description={Total mass of remaining stages (\si{kg}).}]{mr}{\ensuremath{m_r}}
\glsxtrnewsymbol[description={Number of moles of a substance.}]{N}{\ensuremath{N}}
\glsxtrnewsymbol[description={Number of moles of a substance at \(t=0\).}]{N0}{\ensuremath{N_0}}
\glsxtrnewsymbol[description={Position, scalar (\si{m}).}]{rs}{\ensuremath{r}}
\glsxtrnewsymbol[description={Position, scalar, at \(t=0\) (\si{m}).}]{rs0}{\ensuremath{r_0}}
\glsxtrnewsymbol[description={Time (\si{\s}).}]{t}{\ensuremath{t}}
\glsxtrnewsymbol[description={Final time (\si{\s}).}]{tf}{\ensuremath{t_f}}
\glsxtrnewsymbol[description={Radioactive half life (\si{\s}).}]{thalf}{\ensuremath{t_{\left(\nicefrac{1}{2}\right)}}}
\glsxtrnewsymbol[description={Velocity, scalar (\si{m/s}).}]{vs}{\ensuremath{v}}
\glsxtrnewsymbol[description={Initial velocity, scalar (\si{m/s}).}]{vsi}{\ensuremath{v_i}}
\glsxtrnewsymbol[description={System state vector.}]{stvec}{\ensuremath{\mathbf{x}}}
\glsxtrnewsymbol[description={Delta-V (\si{m/s}).}]{deltav}{\ensuremath{\Delta{}v}}
\glsxtrnewsymbol[description={Radioactive decay constant (\si{\per\s}).}]{lambda}{\ensuremath{\lambda}}
\glsxtrnewsymbol[description={Angular frequency (\si{\per\s}).}]{omega}{\ensuremath{\omega}}
\glsxtrnewsymbol[description={Propellant mass fraction.}]{zeta}{\ensuremath{\zeta}}

%------------------------------------------------------------------------------
% DOCUMENT
%------------------------------------------------------------------------------
\begin{document}

% Customized title page with a nice logo
\begin{titlepage}
\begin{center}
  \vspace*{1.5cm}
  {\Huge\textsf{\MakeUppercase{\thetitle}}}\par
  \vspace{1.cm}
  \includegraphics[width=0.8\textwidth]{fig/logo-text.pdf}\par
  \vspace{1.cm}
  {\Large\textsf{\theauthor}}\par
  \vspace{0.2em}
  {\Large\textsf{\thedate}}\par           
  \vspace{0.5cm}
  \rule{2cm}{0.5pt}\\\vspace{0.2cm}
  \textsf{Version timestamp: PUBDATE}
\end{center}
\end{titlepage}

\tableofcontents

\chapter{Introduction}

This workshop consists of these published notes and a set of problems contained in the associated GitHub Haskell project.

How much of the notes it will be necessary to read depends on the background of an individual participant. Those who are already familiar with numerical methods might be able to skip most of the notes and simply work on the problems directly. However, we have tried to make the notes fairly comprehensive for newcomers, so that people unfamiliar with numerical methods at least have a starting point.

\chapter{ODE Integration and Initial Value Problems}

The models we use for a spacecraft depend upon a set of variables that represent its state at an instant in time. These state variables typically include:
\begin{paritemize}
\item Position
\item Velocity
\item Mass
\end{paritemize}
They may be scalar quantities or vectors, as appropriate to the problem.

Our simulations are all examples of ``Initial Value Problems''. In an initial value problem, we know the starting state of the spacecraft, and we have a set of first-order ordinary differential equations (ODEs), which describe how its state evolves with time. We will integrate these ODEs to predict the state at future times. Using this approach, we can compute the time history of state variables that are critial to mission or maneuver planning. For example, we might find the trajectory of a spacecraft (its position as a function of time), and check whether it places the spacecraft in a desired orbit.

The motion of a spacecraft depends on multiple forces that might be acting on it. For example:
\begin{paritemize}
\item Gravity
\item Atmospheric drag
\item Rocket thrust
\end{paritemize}
Thrust from a rocket engine may be controlled, and control inputs can be modeled easily in our system. Testing the behavior of a control system, particularly under conditions of real-world variations, is a modern practical use of the methods we cover (eg.~\cite{prince2011, brauer1977}).

\section{1D Euler's Method}

We can write a set of coupled, first-order ODEs as:
\begin{align}
  \frac{d\gls{stvec}}{d\gls{t}} &= \dot{\gls{stvec}} = \gls{f}(\gls{t}, \gls{stvec})
\end{align}
Here, \gls{stvec} is the state vector, \gls{t} is time, and \gls{f} is some function. In Euler's method, we approximate a step forward in time by adding the product of the gradient, \(\dot{\gls{stvec}}\), and the time step, \gls{dt}, to the current state, \gls{stvec}:
\begin{align}
  \gls{stvec}(\gls{t} + \gls{dt})
  &\approx \gls{stvec}(\gls{t}) + \dot{\gls{stvec}}\,\gls{dt} \\
  &\approx \gls{stvec}(\gls{t}) + \gls{f}\left(\gls{t}, \gls{stvec}(\gls{t})\right)\,\gls{dt}
\end{align}

\subsection{Radioactive Decay}

We will begin implementing Euler's method with a 1D state, specialized to \code{Double}, using the process of radioactive decay as an example. Radioactive decay has an analytical solution, thus providing a ground truth against which the numerical result can be compared. It only involves a single state variable, \gls{N}, which can be represented as a \code{Double}. Specializing to \code{Double} gives us a simple starting point that is close to the approach used in many other programming languages.

In radioactive decay, the rate of decay, \(\dot{\gls{N}}\), is proportional to the number of moles of radioactive particles that remain at any instant in time, \gls{N}:
\begin{align}
  \dot{\gls{N}} &= -\gls{lambda}\gls{N}
\end{align}
where \gls{lambda} is called the decay constant. This equation can be solved by knowing in advance that an exponential function happens to fit exactly the expected equation:
\begin{align}
  \gls{N} &= \gls{N0} \exp\left({-\gls{lambda}\gls{t}}\right)
\end{align}
So that:
\begin{align}
  \dot{\gls{N}} &= -\gls{lambda}\left(\gls{N0}\exp\left({-\gls{lambda}\gls{t}}\right)\right) \\
                &= -\gls{lambda}\gls{N}
\end{align}
as required. Conventionally, \gls{lambda} is specified in terms of the half-life of an isotope, \gls{thalf}:
\begin{align}
  \textrm{at } \gls{t} &= 0,\: \gls{N} = \gls{N0} \\
  \textrm{at } \gls{t} &= \gls{thalf},\: \gls{N} = \frac{\gls{N0}}{2}
\end{align}
thus:
\begin{align}
  \frac{\gls{N0}}{2} &= \gls{N0}\exp\left({-\gls{lambda}\gls{thalf}}\right) \\
  \ln\left(\tfrac{1}{2}\right) &= -\gls{lambda}\gls{thalf} \\
  \gls{lambda} &= \frac{\ln 2}{\gls{thalf}}
\end{align}
As an example, consider the isotope Plutonium-238 (\isotope[238]{Pu}), which has been used in radioisotope thermoelectric generators (RTGs) for spacecraft such as the Voyager 1 and 2 probes. This isotope has a half-life of approximately 87.7 years.

\begin{problem}[label=eulerStepDouble]{Euler integration specialized to \code{Double}.}
  In the file \filename{ODE.hs},
  \begin{probitemize}
  \item implement \code{eulerStepDouble}, which takes a single step of Euler integration
  \item implement \code{integrateEulerDouble}, which takes multiple steps
  \end{probitemize}
  In \filename{ODEExamples.hs},
  \begin{probitemize}
  \item run \code{plotEulerDoubleExpDecay Screen}, to view a plot of Euler integration applied to the radioactive decay example
  \end{probitemize}
\end{problem}

\begin{figure}[htbp]
  \centering
  \resizebox{\textwidth}{!}{\input{fig/euler-double-exp-decay}}
  \caption{Comparison of Euler integration with the analytical result for radioactive decay of the isotope \isotope[238]{Pu}. The solid line shows the analytical solution while the points demonstrate the Euler approximation for different time steps.}
  \label{fig:euler-double-exp-decay}
\end{figure}

Figure~\ref{fig:euler-double-exp-decay} shows the result of applying Euler integration to the radioactive decay example. In this figure, it is evident that when smaller time-steps are taken, the Euler method more closely approximates the analytical solution. This is usually the case practically with numerical integration, although there is a limit beyond which smaller time steps will begin to diverge from the correct solution due to accruing floating-point errors. We will see later that raising the polynomial order of the integration approximation can improve accuracy with greater computational efficiency than taking smaller time steps.

\section{Euler's Method for an \code{AffineSpace} State}

We will now generalize Euler's method using the abstractions available in the \hspackage{vector-space} package. The necessary constraints are captured in Listing~\ref{lst:euler-vector-space}. Don't panic if this seems a lot to take in, since we'll see a few concrete examples.

\begin{listing}[htbp]
\begin{minted}[fontsize=\small]{haskell}
eulerStep
  :: ( AffineSpace state
     , diff ~ Diff state, VectorSpace diff
     , HasBasis time, HasTrie (Basis time)
     , s ~ Scalar diff, s ~ Scalar time )
  => time                              -- ^ Step size @dt@
  -> ((time, state) -> time :-* diff)  -- ^ Gradient function @f (x, t)@
  -> (time, state)                     -- ^ Before the step @(t, x)@
  -> (time, state)                     -- ^ After the step @(t, x)@
\end{minted}
\caption{Constraints for Euler's method generalized by \hspackage{vector-space}.}
\label{lst:euler-vector-space}
\end{listing}

The first concept we introduce is the difference between an \code{AffineSpace} and its associated \code{VectorSpace}. In the present context, points in the \code{AffineSpace} are points belonging to the state space of the problem, of type \code{state} (eg.~position, velocity, etc). Vectors of the associated \code{VectorSpace}, of type \code{diff}, represent deltas or differences between the points (eg.~an offset of position, a delta in velocity, etc). We can add a vector to a point to obtain a new point, but we don't sum points directly. Similarly, we can multiply a vector by a scalar, but we cannot multiply a point by a scalar. Most widely-used frameworks for numerical integration do not make this distinction.

Next is the concept of a linear map representing the derivative: \code{time :-* diff}. In our case, where we deal with finite differences, this constructor can be considered analogous to a (linear) function of type \code{time -> diff}. What this function represents is the delta, \code{diff}, which arises from taking a time-step, \gls{dt}, of type \code{time}. A very simple illustration of the linear map is shown in Listing~\ref{lst:linear-map-scalar}, with a version for vectors shown in Listing~\ref{lst:linear-map-vector}. The \code{linear} function assumes that the function it has been provided is linear, and it memoizes the values of that function along each basis vector of the vector space.

\begin{listing}[htbp]
\begin{minted}[fontsize=\small]{haskell}
> :set -XFlexibleContexts
> import Data.LinearMap ((:-*), linear, lapply)
> f = (*) 5 :: Double -> Double
> lm = linear f
> :t lm
lm :: Double :-* Double
> :force lm
lm = Data.LinearMap.LMap (Just 5.0)
> lapply lm 1.0
5.0
> lapply lm 2.0
10.0
\end{minted}
\caption{A scalar linear map. Once the map has been defined (by the \code{linear} function), the \code{lapply} function multiplies the input vector (a \code{Double}) by the memoized value along the unit basis vector.}
\label{lst:linear-map-scalar}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[fontsize=\small]{haskell}
> :set -XFlexibleContexts
> import Data.LinearMap ((:-*), linear, lapply)
> :{
| f :: (Double, Double) -> (Double, Double, Double)
| f (x, y) = (2*x + y, 3*x - y, 4*y)
| :}
> lm = linear f
> :force lm
lm = Data.LinearMap.LMap
     (Just
       (Data.MemoTrie.EitherTrie ((,,) 2.0 3.0 0.0) ((,,) 1.0 -1.0 4.0)))
> lapply lm (5, 6)
(16.0,9.0,24.0)
\end{minted}
\caption{A vector linear map, using tuples for vectors. This provides a better view of the memoisation that is occurring under the hood. The construction of a matrix-like representation (but with automatic dimension checking) is evident.}
\label{lst:linear-map-vector}
\end{listing}

Finally, we need to describe the operations that can be used on instances of \code{AffineSpace} and its associated \code{VectorSpace}:
\begin{pardescription}[leftmargin=6em,style=nextline]
\item [\code{lapply m h}] applies linear map \code{m} to vector \code{h}
\item [\code{p .+\^{} v}] adds vector \code{v} to point \code{p}
\item [\code{a \^{}+\^{} b}] adds vector \code{a} to vector \code{b}
\end{pardescription}
These operations are sufficient to implement the generalized form of Euler's method.

\subsection{Simple Harmonic Motion}

To motivate the generalized form of Euler's method, let's consider simple harmonic motion (SHM), with two scalar state variables:
\begin{paritemize}
\item Position, \gls{rs}
\item Velocity, \gls{vs}
\end{paritemize}
The data type \code{State} in \filename{ODEExamples.hs} describes this state, which is the \code{AffineSpace} of the problem. It introduces statically type-checked units from the \hspackage{units} package for length and velocity. The data type \code{DState} is the correspondng \code{VectorSpace} of the problem, representing deltas in the state.

In SHM, a linear spring force, \gls{Fs}, is proportional to the position, \gls{rs}, with a spring constant, \gls{k}:
\begin{align}
  \gls{Fs} &= -\gls{k}\gls{rs}
\end{align}
This is combined with the equations of motion of a point mass to produce the following governing ODE:
\begin{align}
  \dot{\gls{stvec}} =
  \begin{bmatrix}\dot{\gls{rs}}\\\dot{\gls{vs}}\end{bmatrix} &=
  \begin{bmatrix}\gls{vs}\\-k\gls{rs}/\gls{m}\end{bmatrix}
\end{align}
where \gls{vs} is the velocity and \gls{m} is the mass. If the initial conditions of the problem at \(\gls{t} = 0\) are \(\gls{rs} = \gls{rs0}\) and \(\gls{vs} = 0\) then the analytical solution is:
\begin{align}
  \gls{stvec}(t) &=
  \begin{bmatrix}
    \gls{rs0}\cos(\gls{omega}t) \\
    -\gls{omega}\gls{rs0}\sin(\gls{omega}t)
  \end{bmatrix}
\end{align}
in which \gls{omega} is the angular velocity, given by:
\begin{align}
  \gls{omega} &= \sqrt{\frac{\gls{k}}{\gls{m}}}
\end{align}
This analytical solution can be differentiated twice manually to confirm that it satisfies the governing ODE, and values substituted to confirm that it satisfies the initial conditions.

\begin{problem}[label=eulerStepVectorSpace]{Generalized Euler integration.}
  In the file \filename{ODE.hs},
  \begin{probitemize}
  \item implement \code{eulerStep}
  \item implement \code{integrate} and \code{integrateWithDiff}
  \end{probitemize}
  In \filename{ODEExamples.hs},
  \begin{probitemize}
  \item run \code{plotEulerSHM Screen}, to view a plot of the position state variable, computed by Euler integration of SHM equations
  \end{probitemize}
\end{problem}

\begin{figure}[htbp]
  \resizebox{\textwidth}{!}{\input{fig/euler-shm}}
  \caption{Comparison of Euler integration with the analytical result for the position variable of a simple harmonic oscillator. The solid line shows the analytical solution while the points demonstrate the Euler approximations for different time steps.}
  \label{fig:euler-shm}
\end{figure}

Figure~\ref{fig:euler-shm} shows the position variable of a simple harmonic oscillator example. Once again, the smaller the time step, the more closely the result tracks the analytical solution.

\section{4th-Order Runge-Kutta Integration}

We have used Euler integration so far because it introduced the concepts we rely on from \hspackage{vector-space}. However, there is a more common default for numerical integration of ODEs: the 4th-Order Runge-Kutta method (RK4). RK4 is the default in Matlab and SciPy (in those packages it is typically used with an embedded 5th-order approximation for step-size control; something we won't implement here). RK4 is usually a much better choice than the Euler method in terms of the accuracy/performance tradeoff.

RK4 is definitely not the final word though! The popular Numerical Recipes textbook recommends an 8th-order method (Dopr853) for general production use in non-stiff systems \cite{press2007}. Specialized integrators may also be used for particular problems. The Apollo Guidance Computer used Nystr\"om's Method to perform integration for efficiency and because of the dominant effect of a single, central gravitational force in most situations \cite{levine1971}.\footnote{The Draper Lab Apollo documents do refer to RK4 though, as ``The usual fourth-order Runge-Kutta integration''. Apparently it has a long history as the ``go to'' approach!} Long-duration astrodynamics problems, such as those concerning solar-system formation, or the behaviour of orbits over thousands of years, may have to use symplectic integrators to achieve reasonable accuracy (eg.~\cite{rein2017}). We don't investigate these methods here because of time limitations, and because RK4 is both easy to implement and entirely sufficient for the examples.

We will only supply the equations for RK4 here and refer readers elsewhere (eg.~\cite{press2007,battin1999}) for a complete derivation:
\begin{align}
\mathbf{k_1} &= \gls{dt}\,\gls{f}(\gls{t},\gls{stvec})\\
\mathbf{k_2} &= \gls{dt}\,\gls{f}(\gls{t} + \tfrac{1}{2}\gls{dt}, \gls{stvec} + \tfrac{1}{2}\mathbf{k_1})\\
\mathbf{k_3} &= \gls{dt}\,\gls{f}(\gls{t} + \tfrac{1}{2}\gls{dt}, \gls{stvec} + \tfrac{1}{2}\mathbf{k_2})\\
\mathbf{k_4} &= \gls{dt}\,\gls{f}(\gls{t} + \gls{dt}, \gls{stvec} + \mathbf{k_3}) \\
\gls{stvec}(\gls{t} + \gls{dt})
  &\approx
  \gls{stvec} +
  \tfrac{1}{6}\mathbf{k_1} +
  \tfrac{1}{3}\mathbf{k_2} +
  \tfrac{1}{3}\mathbf{k_3} +
  \tfrac{1}{6}\mathbf{k_4}
\end{align}
The vectors \(\mathbf{k_1}\ldots\mathbf{k_4}\) can be treated as stages of the computation, and are good candidates for let-floating. However, be aware that these equations do not directly represent the Haskell code. Instead, when implementing them, some care must be taken to consider what components are computed by \code{lapply}, what operations are adding vectors, and what operations are offsetting a point by a vector. Determining these are left as part of the exercise.

\begin{problem}[label=rk4shm]{Runge-Kutta Integration.}
  In the file \filename{ODE.hs},
  \begin{probitemize}
  \item implement \code{rk4Step}
  \end{probitemize}
  In \filename{ODEExamples.hs},
  \begin{probitemize}
  \item run \code{plotSHMComparison Screen}, to view a plot of Euler vs RK4 for the SHM example, using the same number of function evaluations
  \end{probitemize}
\end{problem}

Figure~\ref{fig:shm-comparison} shows the comparison of Euler's method and RK4, for the same number of function evaluations. It is clear that RK4 much more closely approximates the analytical result.

\begin{figure}[htbp]
  \resizebox{\textwidth}{!}{\input{fig/shm-comparison}}
  \caption{Comparison of Euler and RK4 integrations, for the same number of function evaluations, with the analytical result of a simple harmonic oscillator.}
  \label{fig:shm-comparison}
\end{figure}

\section{Simulating Apollo Lunar Ascent}

Now that we have a working integrator, it's possible to look at an example of a somewhat realistic simulation: the algorithm used for Lunar Ascent Guidance during the Apollo missions. This algorithm is described in summary by a NASA technical report \cite{bennett1970} and in much greater detail by an MIT Draper Lab document \cite{levine1971}, which contains sufficient detail to implement the algorithm.

This section contains a ``pre-baked'' scenario that uses the code written in this chapter to run a prepared simulation of the Apollo Lunar Ascent. We do not expect participants to be able to cover all the details in the available time, so much of the information in this section is provided only to give a high-level overview.

The approach we use for simulation involves checking-in with our version of the Apollo Guidance Computer (AGC) every \SI{2}{\s} of simulation time, matching the polling that was used in the original AGC. The ascent guidance returns a commanded thrust angle and an optional engine shutoff time. We take the commanded thrust angle and compute an angular acceleration that will point the ascent stage at that angle by the end of the \SI{2}{\s} period. This approximates the behaviour of the original Digital Autopilot, which achieved the same thing by firing the Reaction Control System (RCS) thrusters. We then integrate the equations of motion forward for \SI{2}{\s} before polling the AGC once again. This swapping between calls to the AGC and forward integration continues until we reach the commanded engine shutoff time, at which point we stop the thrust from the Ascent Propulsion System (APS) engine. Following the burn phase, we take its final state as the initial conditions of a new integration, and integrate the equations of motion for a further \SI{10000}{\s} to numerically compute the coasting trajectory.

A rare feature of this simulation is that it incorporates statically-checked units, from the \hspackage{units} package. Whether or not that was a worthwhile exercise is debatable, as the overhead and extra code complexity is somewhat overwhelming. However, we do have static confirmation that almost all aspects of the algorithm use consistent units.

The ascent guidance used the following parameters as a target:
\begin{paritemize}
\item target velocity (a 2D vector in our version; 3D in the original)
\item target radius (a scalar distance measured from the center of the moon)
\item distance from the Command Service Module (CSM) orbital plane (removed in our version)
\end{paritemize}
During the Apollo missions, the desired insertion orbit of the ascent stage was computed by Misson Control in advance of starting the ascent. That orbit determined the target parameters. In our simulation, we did not perform those calculations, but instead used the target parameters for a ``quick, early takeoff'', which were programmed by default into the AGC, and would typically be overridden by the astronauts under nominal conditions \cite{levine1971}. The phase of the orbit relative to the CSM would be set approximately, by knowing the nominal ascent duration and scheduling the takeoff accordingly \cite{levine1971}. Rendezvous with the CSM was an entirely different manouvre, performed after the ascent, and not part of the ascent guidance \cite{levine1971}.

The inner workings of the guidance algorithm are somewhat outside the scope of this workshop, and in fact are not derived in the Draper Lab document \cite{levine1971}. We can roughly describe our inferred understanding of the approach based upon other texts. A detailed derivation of multiple types of guidance is provided by Battin \cite{battin1999}, who was a core member of the Draper Lab during the Apollo era. A freely-available derivation that quite closely matches the Apollo algorithm is also provided by Townsend et al.~\cite{townsend1968}, although those authors do not specifically mention Apollo.

Given the ascent target parameters, the guidance begins each polling loop by computing a velocity-to-be-gained. This is the difference between the target velocity and the current velocity, corrected for any velocity losses during the burn from gravitational acceleration. The change in velocity due to gravity was given by an expression obtained by integrating the gravitational acceleration analytically. The upper limit of that integration required an approximation of the remaining burn time (time-to-go estimate). The initial time-to-go estimate was a hard-coded value, but subsequent iterations obtained an estimate from a Taylor Series expansion of the well-known Tsiolkovsky Rocket Equation (see Section~\ref{sec:tsiolkovsky}), using the velocity-to-be-gained as the delta-V. Finally, a control law, referred to as the ``linear guidance concept'' \cite{levine1971}, was used to choose the commanded thrust direction, so that the velocity-to-be-gained would fall to zero at the end of the burn, thus matching the target velocity, and the target radius would also be achieved. In addition, the algorithm contained several, somewhat more ad-hoc tweaks, such as prioritising radial thrust and performing bang-bang directional control of radial acceleration if the target radius was reached early.

Given the Draper Lab's prior involvement with ballistic missile projects, such as the Minuteman ICBMs \cite{dennis2018}, the ascent guidance algorithm seems quite likely to have been influenced by missile systems. It also seems likely that earlier practical tests of those systems and other rockets lent some confidence to the early choice of guidance approaches. However, it is naturally extremely difficult to track down any details of large weapons systems for final confirmation.\footnote{I tried. Hopefully I'm not on any (additional) watch lists now. - J.~Merritt.}

In our version of the algorithm, we have made some minor simplifications to suit this workshop, none of which are substantial changes to the core algorithm or guidance concept. The main changes and approximations are:
\begin{itemize}
\item We projected the problem into 2D, by removing the parameter specifying the distance from the CSM orbital plane, and removing the associated control parameters. Mathematically, this is identical to launching in the CSM orbital plane and remaining there, so it is simply a special case of the full guidance algorithm.
\item We removed the thrust filter computations and associated pre-launch initializations, since we don't model the behaviour and noise characteristics of the inertial guidance unit. Instead, we used the nominal initial value for the thrust, based on stored values for the APS exhaust velocity and mass flow rate.
\item We did not allow the RCS to substitute for the APS, and we did not consider modeling abort scenarios.
\item We did not include lunar rotation in the initial conditions (our initial velocity is zero).
\item The Average-G routine is substituted with a simpler version.
\item Window Pointing Direction (WDP) is unused and not specified (it always points toward the center of the moon in the original version anyway).
\item The Digital Autopilot (not technically part of the Ascent Guidance itself) is not modelled in full, and is instead substituted by a piecewise constant angular acceleration.
\item We did not take into account additional thrust produced by +X firing of the RCS for attitude control. Due to the regular angular acceleration, and thus regular RCS burns during ascent, this may result in our slightly underestimating the net thrust.
\item We did not compute any of the user-feedback parameters that were only computed to be displayed on the AGC Display and Keyboard (DSKY), rather than participating in guidance.
\end{itemize}

Although the details above are unlikely to be investigated deeply during the workshop, the larger point is to demonstrate that a relatively involved control algorithm can be simulated using the integration approaches developed in this chapter.

\begin{problem}[label=lunar-ascent-guidance]{Using the RK4 Integrator to Simulate Apollo Lunar Ascent Guidance.}
  In the file \filename{LunarAscent.hs},
  \begin{probitemize}
  \item run \code{plotLunarAscentVerticalRise Screen}, to view the vertical rise phase of the ascent
  \item run \code{plotLunarAscentBurnOnly Screen}, to view the entire burn phase
  \item run \code{plotLunarAscentMoonView Screen}, to display a moon-centred view of the burn and coasting 
  \end{probitemize}
\end{problem}

Figure~\ref{fig:lunar-ascent-vertical-rise} shows the initial vertical rise phase of the lunar ascent. This closely matches the published vertical rise phase reported in Bennett~\cite{bennett1970} (Figure~13). Figure~\ref{fig:lunar-ascent-burn-only} shows the entire orbital insertion phase, which corresponds to Figures~14 and 15 from Bennett~\cite{bennett1970}. Finally, Figure~\ref{fig:lunar-ascent-moon-view} shows a moon-centred view of the burn and later coasting orbit, computed numerically. In Figure~\ref{fig:lunar-ascent-moon-view}, the radial altitude above the moon is magnified by a factor of 10 to better distinguish the orbits. This is common in many illustrations of lunar orbits (for example, Figure~12 of Bennett~\cite{bennett1970}).

\begin{figure}[htbp]
  \resizebox{\textwidth}{!}{\input{fig/lunar-ascent-vertical-rise}}
  \caption{The first \SI{16}{\s} of lunar ascent, including the vertical rise phase.}
  \label{fig:lunar-ascent-vertical-rise}
\end{figure}

\begin{figure}[htbp]
  \resizebox{\textwidth}{!}{\input{fig/lunar-ascent-burn-only}}
  \caption{The entire burn phase of the lunar ascent, shown using altitude-downrange coordinates. The altitude is the radial height above the moon surface, while downrange is the arc-length distance travelled when projected radially downward onto the lunar surface.}
  \label{fig:lunar-ascent-burn-only}
\end{figure}

\begin{figure}[htbp]
  \centering
  \resizebox{0.5\textwidth}{!}{\input{fig/lunar-ascent-moon-view}}
  \caption{Moon-centred view of the burn and coasting phases. The radial (altitude) scale above the lunar surface is magnified by a factor of 10.}
  \label{fig:lunar-ascent-moon-view}
\end{figure}

\chapter{Rocket Staging and the Tsiolkovsky Rocket Equation}

Rockets that deliver payloads to Earth orbit usually have multiple stages. There are several reasons for using multi-stage rockets, including:

\begin{itemize}
\item Reduced fuel use. This is achieved by discarding portions of the rocket that were only used to support the fuel that was previously being carried.
\item Selection of rocket engines that are optimised for different parts of the atmosphere or a vacuum. For example, the optimal nozzle geometry of liquid fuel rocket engines depends on the ambient pressure \cite{marble1964,huzel1967}.
\item Economic factors. Earlier rocket stages can often be returned to Earth, recovered and re-used more cheaply than a single stage, due to lower mass and less downrange displacement.
\end{itemize}

We will examine the first of these benefits by considering the Tsiolkovsky Rocket Equation. This equation is often used as the basis of high-level discussions of mission planning and rocket capabilities.

This chapter of the workshop introduces many basic approximations that are frequently used for simulating rockets. We will build a simulation comparing the behaviour of a single-stage and two-stage rocket, to gain experience setting up and solving equations of motion. Then we will analyse the situation analytically to derive the Tsiolkovsky Rocket Equation.

\section{Propellant Mass Fraction}

We shall define the propellant mass fraction of a rocket stage, \gls{zeta}, as the available mass of propellant, \gls{mp}, divided by the total mass of the stage:
\begin{align}
  \gls{zeta} &= \frac{\gls{mp}}{\gls{mp} + \gls{md}}
\end{align}
where \gls{md} is the ``dry mass'' of the stage (ie.\ the mass without any propellant). For real rocket systems, this equation may need to be modified to incorporate factors such as liquid propellant residuals and reserves \cite{holt2009}, but we ignore those components here for simplicity. Rearranging to solve for \gls{md} gives:
\begin{align}
  \gls{md} &= \gls{mp} \left(\frac{1}{\gls{zeta}} - 1\right)
\end{align}
The dry mass, \gls{md}, is the mass of the entire stage without fuel, and thus accounts for the mass of components such as the engines, the fuel tanks, and the payload. However, the payload mass is only approximately 30\% of the dry mass on average \cite{springmann2004}, so most of the dry mass is consumed by non-payload components. This percentage depends heavily on the mission type \cite{gerberich2013}, with wide variation, but it demonstrates the importance of the overall structure of the rocket compared with the payload.

Holt and Monk \cite{holt2009} provide some plots of typical propellant mass fractions for various launch systems. As a nominal figure we will choose \(\gls{zeta}=0.9\) for our simulations.

\section{Specific Impulse}

In our simulation, we will specify that the rocket is burning a bipropellant mixture of liquid oxygen (LOx) and Rocket Propellant-1 (RP1). RP1 is a refined kerosene. This is the propellant system reported to be used by SpaceX Merlin engines.

A commonly-used measure for the performance of a rocket engine is its specific impulse \cite{huzel1967}, \gls{Is}. This represents not just the propellant but the entire engine design. Thus, an \gls{Is} figure could vary somewhat between engines even if they were to use identical propellant. However, bearing this in mind, specific impulse values can be used in the design phase as representative of the performance of a particular propellant, assuming some near-optimal engine were to be provided later. The magnitude of the thrust force, \gls{FTs}, is related to the specific impulse by:
\begin{align}
  \gls{FTs} &= \gls{g0} \gls{Is} \dot{\gls{m}}
  \label{eq:fts-specific-impulse}
\end{align}
where \gls{g0} is the standard acceleration due to gravity and \(\dot{\gls{m}}\) is the mass flow rate of propellant (the rate at which propellant, including both the base fuel and oxidiser, is being burned). In the current discussion, this figure is valid only for a vacuum. Under conditions of atmospheric pressure at sea level, the effective \gls{Is}, and thus the thrust produced, is typically reduced by around 10\% \cite{kephart1971}.

We will specify a LOx-RP1 engine with an \(\gls{Is} = \SI{300}{\s}\) \cite{huzel1967}.\footnote{There are sources on the web, particularly relating to the SpaceX Merlin engines, that quote a figure more like \SI{350}{\s}. However, we were unable to find any high-quality academic or NASA-endorsed references to support this in the time prior to the workshop. The reference we quote has a foreword written by Wernher von Braun, so it seems rather more trustworthy.}

\section{Simulating Staging}

Now let's compare the effect of using one stage vs two for a rocket carrying the same total amount of propellant, with a fixed propellant mass fraction for each stage. We will simulate the rocket burning all its propellant from a zero-velocity start, in a vacuum with no gravitational effects. Table~\ref{tab:staging-param} shows the parameters for the simulation. In the single stage simulation, the propellant mass will be carried in just one stage (Table~\ref{tab:single-stage}), while for the two-stage simulation, it will be split evenly between stages (Table~\ref{tab:two-stage}).

\begin{table}
  \centering
  \begin{tabular}[htbp]{ l r r l }
    \toprule
    Parameter                & Symbol            & Value        & Units     \\ \midrule
    Total propellant mass    & \gls{mp}          & \num{500000} & \si{kg}   \\
    Mass flow rate           & \(\dot{\gls{m}}\) & \num{290}    & \si{kg/s} \\
    Specific impulse         & \gls{Is}          & \num{300}    & \si{s}    \\
    Propellant mass fraction & \gls{zeta}        & \num{0.9}    &           \\
    \bottomrule
  \end{tabular}
  \caption{Rocket parameters for staging simulation.}
  \label{tab:staging-param}
\end{table}

\begin{table}
  \centering
  \begin{tabular}[htbp]{ l r r l }
    \toprule
    Parameter       & Symbol   & Value        & Units     \\ \midrule
    Propellant mass & \gls{mp} & \num{500000} & \si{kg}   \\
    Dry mass        & \gls{md} & \num{55556}  & \si{kg}   \\
    \bottomrule
  \end{tabular}
  \caption{Single-stage starting mass parameters.}
  \label{tab:single-stage}
\end{table}

\begin{table}
  \centering
  \begin{tabular}[htbp]{ l r r r l }
    \toprule
                    &          & \multicolumn{2}{c}{Value}    &           \\ \cmidrule{3-4}
    Parameter       & Symbol   & Stage 1      & Stage 2       & Units     \\ \midrule
    Propellant mass & \gls{mp} & \num{250000} & \num{250000}  & \si{kg}   \\
    Dry mass        & \gls{md} & \num{27778}  & \num{27778}   & \si{kg}   \\
    \bottomrule
  \end{tabular}
  \caption{Two-stage starting mass parameters.}
  \label{tab:two-stage}
\end{table}

The state vector for the simulation will represent the propellant mass, position and velocity:
\begin{align}
  \gls{stvec} &=
  \begin{bmatrix}
    \gls{mp} \\
    \gls{rs} \\
    \gls{vs}
  \end{bmatrix}
\end{align}
While the equation of motion of the system is:
\begin{align}
  \dot{\gls{stvec}} &=
  \begin{bmatrix}
    \dot{\gls{mp}} \\
    \dot{\gls{rs}} \\
    \dot{\gls{vs}}
  \end{bmatrix} =
  \begin{bmatrix}
    -\dot{\gls{m}} \\
    \gls{vs} \\
    \gls{g0}\gls{Is}\dot{\gls{m}} / (\gls{mp} + \gls{md} + \gls{mr})
  \end{bmatrix}
  \label{eq:stage-eom}
\end{align}
where the new symbol, \gls{mr}, is the total mass of all remaining stages. The rate of change of the propellant is the mass flow rate, the rate of change of position is velocity, and the rate of change of velocity is the thrust force (Eq~\ref{eq:fts-specific-impulse}) divided by the total instantaneous mass. The burn for each stage will be conducted for \((\gls{mp}/\dot{\gls{m}})\)~\si{s}, which is the time required to burn all the propellant.

\begin{problem}[label=staging]{Comparison of staging scenarios.}
  In the file \filename{Staging.hs},
  \begin{probitemize}
  \item implement \code{equationOfMotion}
  \item implement \code{burnStage}
  \item implement \code{burnSingleStage}
  \item implement \code{burnTwoStage}
  \item run \code{plotVelocityComparison Screen}, to view a comparison of the velocity profiles achieved by the two different scenarios
  \end{probitemize}
\end{problem}

Figure~\ref{fig:staging-velocity-comparison} shows the effect of staging on the velocity profiles of the two scenarios. As expected, both scenarios are identical until the time at which the first stage of the two-stage scenario is jettisoned. After ejection of the first stage dry mass, the velocity profile of the two-stage rocket increases compared with the single stage rocket.

\begin{figure}[htbp]
  \resizebox{\textwidth}{!}{\input{fig/staging-velocity-comparison}}
  \caption{Velocity profile of the different staging scenarios. The two-stage rocket achieves a substantially higher final velocity despite the same propellant mass.}
  \label{fig:staging-velocity-comparison}
\end{figure}

\section{Tsiolkovsky Rocket Equation}
\label{sec:tsiolkovsky}

We can derive the famous Tsiolkovsky Rocket Equation from Eq~\ref{eq:stage-eom}. Start by subsituting the multiple mass components in the acceleration term by a single instantaneous mass:
\begin{align}
  \dot{\gls{vs}} &= \frac{\gls{g0}\gls{Is}\dot{\gls{m}}}{\gls{m}}
\end{align}
If we burn mass at a uniform rate then the instantaneous mass, \gls{m}, can be written as:
\begin{align}
  \gls{m}(\gls{t}) &= \gls{mi} - \dot{\gls{m}}\gls{t}
\end{align}
where \gls{mi} is the initial mass. Then we can integrate this equation to find the change in velocity due to the burn (final velocity, \gls{vs}, minus initial velocity, \gls{vsi}) as follows:
\begin{align}
  \gls{vs}
  &=
  \int_0^{\gls{tf}}\dot{\gls{vs}}\,d\gls{t} \\
  &=
  \int_0^{\gls{tf}}\frac{\gls{g0}\gls{Is}\dot{\gls{m}}}{\gls{mi} - \dot{\gls{m}}\gls{t}}\,d\gls{t} \\
  &=
  \gls{g0}\gls{Is}\dot{\gls{m}}
  \left[
    \frac{1}{-\dot{\gls{m}}}\ln\left(\gls{mi} - \dot{\gls{m}}\gls{t}\right)
    \right]^{\gls{tf}}_0 + \gls{vsi} \\
  &=
  \gls{g0}\gls{Is}
  \left(
    \ln\gls{mi} - \ln(\gls{mi} - \dot{\gls{m}}\gls{tf})
  \right) + \gls{vsi}
\end{align}
\begin{align}
  \gls{vs} - \gls{vsi} = \gls{deltav}
  &=
  \gls{g0}\gls{Is} \ln\left(\frac{\gls{mi}}{\gls{mf}}\right)
  \label{eq:tsiolkovsky}
\end{align}
where \gls{tf} is the duration or final time of the burn. \gls{mf} is the final mass, given by \(\gls{mf} = \gls{mi} - \dot{\gls{m}}\gls{tf}\). Eq~\ref{eq:tsiolkovsky} is the famous Tsiolkovsky Rocket Equation.

The quantity \gls{deltav} (``Delta Vee'') is the change in vehicle velocity that would occur under the conditions we have described above: a vacuum burn with no gravity. This quantity expresses the ``magnitude'' of a spacecraft manouevre without referencing the mass of the system, which is of course always changing. Thus, it's a popular way to gauge the requirements of various manouevres in mission planning (eg.~\cite{bennett1970}). Due to the logarithm that appears in the equation, \gls{deltav} requirements of multiple manouevres compose by addition.

We can thus verify our numerical \gls{deltav} findings from the one- and two-stage rocket configurations. For the single-stage rocket:
\begin{align}
  \gls{deltav}
  &=
  \gls{g0}\gls{Is}\ln\left(
    \frac{\gls{mp}+\gls{md}}{\gls{md}}
  \right) \\
  &=
  \SI{9.81}{m/s^2}\times\SI{300}{s}\times\ln\left(
    \frac{\SI{500000}{kg} + \SI{55556}{kg}}{\SI{55556}{kg}}
  \right) \\
  &=
  \SI{6776}{m/s}
\end{align}
And for the two-stage rocket, we simply add the \gls{deltav} from burning each stage (bearing in mind the slightly-different definitions of \gls{mp} and \gls{md}):
\begin{align}
  \gls{deltav}
  &=
  \gls{g0}\gls{Is}
  \left[
    \ln\left(
      \frac{2\gls{mp} + 2\gls{md}}{\gls{mp} + 2\gls{md}}
    \right)
    +
    \ln\left(
      \frac{\gls{mp} + \gls{md}}{\gls{md}}
    \right)
  \right] \\
  &= \SI{8536}{m/s}
\end{align}


% Symbol Glossary
\printunsrtglossary[type=symbols,style=long]

% References
\clearpage\phantomsection
\addcontentsline{toc}{chapter}{References}
\bibliographystyle{IEEEtran}
\bibliography{references.bib}

\end{document}
